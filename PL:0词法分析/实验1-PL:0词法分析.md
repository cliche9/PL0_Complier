> {}：出现0次或多次
> []:出现一次或不出现

## PL/0语言文法的BNF表示：

〈程序〉→〈分程序〉。

〈分程序〉→ \[<常量说明部分>]\[<变量说明部分>]\[<过程说明部分>]〈语句〉

 <常量说明部分> → CONST<常量定义>{ ,<常量定义>}；

 <常量定义> → <标识符>=<无符号整数>

 <无符号整数> → <数字>{<数字>}

 <变量说明部分> → VAR<标识符>{ ,<标识符>}；

 <标识符> → <字母>{<字母>|<数字>}

 <过程说明部分> → <过程首部><分程序>；{<过程说明部分>}

 <过程首部> → procedure<标识符>；

 <语句> → <赋值语句>|<条件语句>|<当型循环语句>|<过程调用语句>|<读语句>|<写语句>|<复合语句>|<空>

 <赋值语句> → <标识符>:=<表达式>

 <复合语句> → begin<语句>{ ；<语句>}\<end>

 <条件> → <表达式><关系运算符><表达式>|odd<表达式>

 <表达式> → [+|-]<项>{<加减运算符><项>}

 <项> → <因子>{<乘除运算符><因子>}

 <因子> → <标识符>|<无符号整数>|(<表达式>)

 **<加减运算符> → +|-**

 **<乘除运算符> → *|/**

 **<关系运算符> → =|#|<|<=|>|>=**

 <条件语句> → if<条件>then<语句>

 <过程调用语句> → call<标识符>

 <当型循环语句> → while<条件>do<语句>

 <读语句> → read(<标识符>{ ，<标识符>})

 <写语句> → write(<标识符>{，<标识符>})

 **<字母> → a|b|c…x|y|z**

 **<数字> → 0|1|2…7|8|9**

## 一． PL/0语言实现词法分析

> 把**关键字、算符、界符**称为语言固有的单词；
>
> **标识符、常量**称为用户自定义的单词。
>
> 为此设置两个全程量：NAME，SYM 。
>
> SYM：存放每个单词的类别。
>
> NAME：存放单词值。

### 要完成的任务：

1. 滤掉单词间的空格。
2. ==识别关键字==，用查关键字表的方法识别。当单词是关键字时，将对应的类别放在SYM中。如IF的类别为IFSYM，THEN的类别为THENSYM。
3. ==识别标识符==，标识符的类别为IDENT，IDENT放在SYM中，标识符本身的值放在NAME中。
4. 拼数，将数的类别NUMBER放在SYM中，数本身的值放在NAME中。
5. ==拼由两个字符组成的运算符==，如：>=、<=等等，识别后将类别存放在SYM中。
6. 打印源程序，边读入字符边打印。

==注意：由于一个单词是由一个或多个字符组成的，所以需实现一个读字符过程。==

### 实验步骤

* 构建NAME - SYM映射表

  | 关键词 | 关键词 + ”sys“ |
  | ------ | -------------- |
  | +      | plus           |
  | -      | minus          |
  | *      | times          |
  | /      | over           |
  | =      | eql            |
  | <      | lss            |
  | <=     | leq            |
  | >      | gtr            |
  | >=     | geq            |
  | <>     | neq            |
  | :=     | assign         |
  | (      | lparen         |
  | )      | rparen         |
  | ;      | semicolon      |
  | ,      | comma          |
  | .      | period         |

* 

 

 

 

 